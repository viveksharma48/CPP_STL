#include<iostream>#include<exception>using namespace std;/*Class which will contain methords(functions) to throwcustom and standerd exceptions and each exception will becaught differently*/class custom: public exception{   public:	/*	function returning a string for object.what() 	*/		virtual const char *what(){		return "Something went bad !";	}	};class Test{public:		/*	methord (function) throwing exception of custom type	*/		void goeswrong(){		throw custom();	}	void calculate (int firstNumber, int secondNumber){		firstNumber/secondNumber;	}	void gowrong (){		int *a = new int [9999999999999999];		delete[] a;	}	/*void err (){		throw bad_cast();	}*/};struct Foo { virtual ~Foo() {} };struct Bar { virtual ~Bar() {} };int main(int argc, char const *argv[]){	Bar b;	Test test;	try{		test.goeswrong();	}	catch (custom &e){												//Catching Exception of custom type		cout << "Caught an exception " << e.what() <<endl;	}	try{		test.calculate(11,0);	}	catch (logic_error &e){											//Catching Exception of can't divide by zero		cout<< "Error accoured" << e.what() << endl;	}	try{		Foo& f = dynamic_cast<Foo&>(b);	}	catch (exception &e){											//Catching Exception of genric type(predifined)		cout << "Caught an Exception of type " << e.what() << endl;	}	try{				/*		you can litrally try anything here		*/		test.gowrong();	}	catch (...){													//Catching Exception of any type		cout << "Something went BAD!! Please repair it " << endl ;	//but can't know about what went wrong	}	return 0;	}